<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="date" content="2021-01-19" />
<link rel="stylesheet" href="https://shijingchang.cn/doc/assets/css/tufte.min.css">
<link href="https://fonts.loli.net/css2?family=Fira+Code&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://shijingchang.cn/doc/assets/css/extra.css">
<link href="https://cdn.bootcdn.net/ajax/libs/KaTeX/0.16.6/katex.min.css" rel="stylesheet">
<script src="https://cdn.bootcdn.net/ajax/libs/KaTeX/0.16.6/katex.min.js"></script>
<script defer src="https://cdn.bootcdn.net/ajax/libs/KaTeX/0.16.6/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
</head>

<body>
<div id="header">
<h1 class="title">Fortran</h1>
<h3 class="date">2021-01-19</h3>
<div id="TOC">
<ul>
<li><a href="#basics" id="toc-basics"><span
class="toc-section-number">1</span> Basics</a>
<ul>
<li><a href="#module" id="toc-module"><span
class="toc-section-number">1.1</span> Module</a>
<ul>
<li><a href="#explanation-on-submodule"
id="toc-explanation-on-submodule"><span
class="toc-section-number">1.1.1</span> Explanation on
submodule</a></li>
</ul></li>
<li><a href="#io" id="toc-io"><span
class="toc-section-number">1.2</span> I/O</a>
<ul>
<li><a href="#binaryhex-representation-of-number"
id="toc-binaryhex-representation-of-number"><span
class="toc-section-number">1.2.1</span> Binary/Hex Representation of
Number</a></li>
<li><a href="#big-endian-and-little-endian"
id="toc-big-endian-and-little-endian"><span
class="toc-section-number">1.2.2</span> Big Endian and Little
Endian</a></li>
<li><a href="#example" id="toc-example"><span
class="toc-section-number">1.2.3</span> Example</a></li>
<li><a href="#use-python-to-manipulate-fortran-binary-file"
id="toc-use-python-to-manipulate-fortran-binary-file"><span
class="toc-section-number">1.2.4</span> Use Python to Manipulate Fortran
Binary File</a></li>
</ul></li>
<li><a href="#array" id="toc-array"><span
class="toc-section-number">1.3</span> Array</a>
<ul>
<li><a href="#equivalent-to-matlab-find"
id="toc-equivalent-to-matlab-find"><span
class="toc-section-number">1.3.1</span> Equivalent to MATLAB
<code>find</code></a></li>
<li><a href="#avoid-temporary-array-created"
id="toc-avoid-temporary-array-created"><span
class="toc-section-number">1.3.2</span> Avoid Temporary Array
Created</a></li>
<li><a href="#set-multidimensional-array"
id="toc-set-multidimensional-array"><span
class="toc-section-number">1.3.3</span> Set Multidimensional
Array</a></li>
</ul></li>
</ul></li>
<li><a href="#advanced" id="toc-advanced"><span
class="toc-section-number">2</span> Advanced</a>
<ul>
<li><a href="#oop" id="toc-oop"><span
class="toc-section-number">2.1</span> OOP</a>
<ul>
<li><a href="#final-finalizer-of-class"
id="toc-final-finalizer-of-class"><span
class="toc-section-number">2.1.1</span> <code>FINAL</code>: finalizer of
class</a></li>
<li><a href="#function-as-user-defined-type-constructor"
id="toc-function-as-user-defined-type-constructor"><span
class="toc-section-number">2.1.2</span> Function as user-defined type
constructor</a></li>
<li><a href="#polymorphic-variable" id="toc-polymorphic-variable"><span
class="toc-section-number">2.1.3</span> Polymorphic variable</a></li>
</ul></li>
<li><a href="#practices" id="toc-practices"><span
class="toc-section-number">2.2</span> Practices</a>
<ul>
<li><a href="#passing-null-pointer" id="toc-passing-null-pointer"><span
class="toc-section-number">2.2.1</span> Passing null pointer</a></li>
<li><a href="#multidimensional-array"
id="toc-multidimensional-array"><span
class="toc-section-number">2.2.2</span> Multidimensional Array</a></li>
<li><a href="#array-of-pointer" id="toc-array-of-pointer"><span
class="toc-section-number">2.2.3</span> Array of Pointer</a></li>
<li><a href="#common-causes-of-segmentation-faults-segfaults"
id="toc-common-causes-of-segmentation-faults-segfaults"><span
class="toc-section-number">2.2.4</span> Common Causes of Segmentation
Faults (Segfaults)</a></li>
</ul></li>
</ul></li>
</ul>
</div>
<div id="wrapper">
<h1 data-number="1" id="basics"><span
class="header-section-number">1</span> Basics</h1>
<h2 data-number="1.1" id="module"><span
class="header-section-number">1.1</span> Module</h2>
<h3 data-number="1.1.1" id="explanation-on-submodule"><span
class="header-section-number">1.1.1</span> Explanation on submodule</h3>
<p>Submodules are a feature added to the language to address one
specific question: separation of interface and implementation. The main
motivation was the compile cascades generated when you needed to change
just a implementation detail in a module.</p>
<p>But Submodules are not Modules!</p>
<p>A submodule is tied to a module and provides implementation to
procedures declared in that module. So, a submodule have access to all
declarations in it’s parent module. Nonetheless, the module doesn’t know
anything about it’s Submodules, and doesn’t USE it’s Submodules like
they were modules. The module just expect you to add Submodules at link
time, enough to cover all the missing procedure implementations.</p>
<p>Reference: <a
href="https://stackoverflow.com/questions/50956497/puting-derived-types-with-procedures-from-module-to-submodule">Puting
derived types with procedures from module to submodule</a></p>
<h2 data-number="1.2" id="io"><span
class="header-section-number">1.2</span> I/O</h2>
<p>The <code>direct</code> attribute of the <code>open</code> procedure
does not add header and footer information to each record. Fortran’s
default behavior is the <code>sequential</code> access with header and
footer included. The header and footer store the size of each record. It
seems like both of them store the same info, i.e. the size of bytes of
each record. Check <a href="https://stackoverflow.com/a/10018031">Best
answer to: Opening Binary Files in Fortran: Status, Form, Access</a> for
reference.</p>
<h3 data-number="1.2.1" id="binaryhex-representation-of-number"><span
class="header-section-number">1.2.1</span> Binary/Hex Representation of
Number</h3>
<p>Negative integer represented in binary form uses the <a
href="https://en.wikipedia.org/wiki/Two%27s_complement">two component
system</a>. Basically it is <span class="math inline">\(2^m - n\)</span>
where <span class="math inline">\(-n\)</span> is the negative number and
<span class="math inline">\(m\)</span> is the number of digits in the
binary format. For example, <span class="math inline">\(2^8 - 10 =
246\)</span>. 10 is <code>0a</code>. <code>-10</code> is
<code>f6</code>.</p>
<p>To check the content of a bindary file, in Linux, use
<code>hexdump</code> or <code>xxd</code>. I prefer <code>xxd</code>.</p>
<h3 data-number="1.2.2" id="big-endian-and-little-endian"><span
class="header-section-number">1.2.2</span> Big Endian and Little
Endian</h3>
<p>For the illustration of the big endian and little endian, check the
<a href="https://en.wikipedia.org/wiki/Endianness">Wikipedia link</a>.
It seems like Linux use little endian as the default option.</p>
<figure>
<img
src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/54/Big-Endian.svg/300px-Big-Endian.svg.png"
alt="Big endian" />
<figcaption aria-hidden="true">Big endian</figcaption>
</figure>
<figure>
<img
src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/ed/Little-Endian.svg/300px-Little-Endian.svg.png"
alt="Little endian" />
<figcaption aria-hidden="true">Little endian</figcaption>
</figure>
<h3 data-number="1.2.3" id="example"><span
class="header-section-number">1.2.3</span> Example</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode fortran"><code class="sourceCode fortranfixed"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">program</span> io</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">implicit</span> <span class="kw">none</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">continue</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">call</span> writeBinFile()</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">contains</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">subroutine</span> writeBinFile()</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">integer(4)</span> <span class="dt">::</span> i <span class="kw">=</span> <span class="dv">10</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">continue</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">open(unit</span><span class="kw">=</span><span class="dv">1</span>, <span class="fu">file</span><span class="kw">=</span><span class="st">&#39;data_direct_access.bin&#39;</span>, <span class="fu">form</span><span class="kw">=</span><span class="st">&#39;unformatted&#39;</span>, <span class="kw">&amp;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>         <span class="fu">access</span><span class="kw">=</span><span class="st">&#39;direct&#39;</span>, <span class="fu">recl</span><span class="kw">=</span><span class="dv">1</span>, <span class="fu">status</span><span class="kw">=</span><span class="st">&#39;unknown&#39;</span><span class="fu">)</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">write(unit</span><span class="kw">=</span><span class="dv">1</span>, rec<span class="kw">=</span><span class="dv">1</span><span class="fu">)</span> i</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">write(unit</span><span class="kw">=</span><span class="dv">1</span>, rec<span class="kw">=</span><span class="dv">2</span><span class="fu">)</span> i<span class="kw">*</span><span class="dv">2</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">close(unit</span><span class="kw">=</span><span class="dv">1</span><span class="fu">)</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">!</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="fu">open(unit</span><span class="kw">=</span><span class="dv">2</span>, <span class="fu">file</span><span class="kw">=</span><span class="st">&#39;data_sequential_access.bin&#39;</span>, <span class="fu">form</span><span class="kw">=</span><span class="st">&#39;unformatted&#39;</span>, <span class="kw">&amp;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>         <span class="fu">access</span><span class="kw">=</span><span class="st">&#39;sequential&#39;</span>, <span class="fu">status</span><span class="kw">=</span><span class="st">&#39;unknown&#39;</span><span class="fu">)</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="fu">write(unit</span><span class="kw">=</span><span class="dv">2</span><span class="fu">)</span> i</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="fu">write(unit</span><span class="kw">=</span><span class="dv">2</span><span class="fu">)</span> i<span class="kw">*</span><span class="dv">2</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="fu">close(unit</span><span class="kw">=</span><span class="dv">2</span><span class="fu">)</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end subroutine</span> writeBinFile</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="kw">end program</span></span></code></pre></div>
<p>The output is as follows,</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">-rw-rw-r--.</span> 1 jcshi jcshi     8 Mar  1 18:08 data_direct_access.bin</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ex">-rw-rw-r--.</span> 1 jcshi jcshi    24 Mar  1 18:08 data_sequential_access.bin</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ex">xxd</span> data_sequential_access.bin</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="ex">00000000:</span> 0400 0000 0a00 0000 0400 0000 0400 0000  ................</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="ex">00000010:</span> 1400 0000 0400 0000                      ........</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="ex">xxd</span> data_direct_access.bin</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="ex">00000000:</span> 0a00 0000 1400 0000                      ........</span></code></pre></div>
<p>2 integers of 4 bytes are 8 bytes. It is using the little endian.
<code>0a00 0000</code> is <code>10</code>, <code>1400 0000</code> is
<code>20</code>. The header and footer store the size of bytes
<code>4</code>.</p>
<h3 data-number="1.2.4"
id="use-python-to-manipulate-fortran-binary-file"><span
class="header-section-number">1.2.4</span> Use Python to Manipulate
Fortran Binary File</h3>
<p><a
href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.FortranFile.html"><code>scipy.io.FortranFile</code></a>
could be used to read in Fortran binary file to check it content.</p>
<h2 data-number="1.3" id="array"><span
class="header-section-number">1.3</span> Array</h2>
<h3 data-number="1.3.1" id="equivalent-to-matlab-find"><span
class="header-section-number">1.3.1</span> Equivalent to MATLAB
<code>find</code></h3>
<pre><code>I = pack([(j,j=1,size(v))],v==3)</code></pre>
<h3 data-number="1.3.2" id="avoid-temporary-array-created"><span
class="header-section-number">1.3.2</span> Avoid Temporary Array
Created</h3>
<p>When the actual argument array (i.e. declared in the calling routine)
is deferred-shape or assumed-shape array and the dummy argument array
(i.e. declared in the routine being called) is the explicit-shape array,
the program will create an temporary array which slows the program a
lot. Check this <a
href="http://wiki.seas.harvard.edu/geos-chem/index.php/Passing_array_arguments_efficiently_in_GEOS-Chem">link</a>
for the details.</p>
<blockquote>
<p>The array temporary is created because the passed array may not be
contiguous and the receiving (explicit-shape) array requires a
contiguous array. When an array temporary is created, the size of the
passed array determines whether the impact on slowing run-time
performance is slight or severe.</p>
</blockquote>
<p>The following codes illustrate it. The function
<code>func_explicit_shape</code> declares an explicit-shape array
<code>in_arr(1:n1,1:n2)</code> while <code>func_deferred_shape</code>
uses a deferred-shape array <code>in_arr(:,:)</code> where the shape of
the array is obtained by the intrinsic function <code>size()</code>.</p>
<pre><code>program test
  !
  integer :: n1,n2, i,nt
  real(4), dimension(:,:), allocatable :: arr1
  real(4), dimension(:), allocatable :: arr2
  real(4) :: tb,te
  !
continue
  !
  n1 = 4
  n2 = 10240
  allocate(arr1(1:n1,1:n2))
  allocate(arr2(1:n2))
  !
  arr1 = 4
  n1 = 2
  n2 = 5120
  nt = 200000
  !
  call cpu_time(tb)
  do i = 1, nt
    arr2(n2:n2*2-1) = func_explicit_shape(arr1(n1:n1+1,n2:n2*2-1),2,n2)
    arr1(n1,n2:n2*2-1) = arr2(n2:n2*2-1)
  end do
  call cpu_time(te)
  write(*,11) te-tb

  call cpu_time(tb)
  do i = 1, nt
    arr2(n2:n2*2-1) = func_deferred_shape(arr1(n1:n1+1,n2:n2*2-1))
    arr1(n1,n2:n2*2-1) = arr2(n2:n2*2-1)
  end do
  call cpu_time(te)
  write(*,12) te-tb

  deallocate(arr1)
  deallocate(arr2)
  !
11 format(&quot;explicit shaped array costs &quot;,f10.2,&quot; seconds&quot;)
12 format(&quot;deferred shaped array costs &quot;,f10.2,&quot; seconds&quot;)
  !
contains
  !
  pure function func_explicit_shape(in_arr,n1,n2) result(return_value)
    !
    real(4), intent(in) :: in_arr(1:n1,1:n2)
    integer, intent(in) :: n1,n2
    real(4) :: return_value(1:n2)
    !
    integer :: i
    !
  continue
    !
    do i = 1,n2
      return_value(i) = sum( in_arr(1:n1,i) )
    end do
    !
  end function func_explicit_shape
  !
  pure function func_deferred_shape(in_arr) result(return_value)
    !
    real(4), intent(in) :: in_arr(:,:)
    real(4) :: return_value(1:size(in_arr,dim=2))
    !
    integer :: n1,n2
    integer :: i
    !
  continue
    !
    n1 = size(in_arr,dim=1)
    n2 = size(in_arr,dim=2)
    do i = 1,n2
      return_value(i) = sum( in_arr(1:n1,i) )
    end do
    !
  end function func_deferred_shape
  !
end program</code></pre>
<p>Using the Intel Fortran compiler <code>ifort</code> with
<code>-O3 -xHost</code> enabled, the performance of the two versions are
compared as follows,</p>
<pre><code># jcshi @ master in ~/learn [21:26:10]
$ ./test_opt
explicit shaped array costs       1.53 seconds
deferred shaped array costs       1.00 seconds
# jcshi @ master in ~/learn [21:26:17]
$ ./test_opt
explicit shaped array costs       1.64 seconds
deferred shaped array costs       1.00 seconds
# jcshi @ master in ~/learn [21:26:22]
$ ./test_opt
explicit shaped array costs       1.54 seconds
deferred shaped array costs       1.00 seconds</code></pre>
<p>The Intel Fortran compiler has a flag
<code>-check arg_temp_created</code> to check if an temporary array is
created. With this flag, run the debug version will give the following
warning,</p>
<pre><code>forrtl: warning (406): fort: (1): In call to FUNC_EXPLICIT_SHAPE, an array temporary was created for argument #1</code></pre>
<h3 data-number="1.3.3" id="set-multidimensional-array"><span
class="header-section-number">1.3.3</span> Set Multidimensional
Array</h3>
<pre><code>integer :: cell_face_cnt_dir(1:2,1:6,1:3) = 0
cell_face_cnt_dir(1:2,1:6,3) = reshape( &amp;
          [ 1, 1, 2, 1, 2, 1, &amp;
            2, 3, 3, 3, 3, 2 ], shape = [ 2, 6 ], order = [ 2, 1 ] )</code></pre>
<h1 data-number="2" id="advanced"><span
class="header-section-number">2</span> Advanced</h1>
<h2 data-number="2.1" id="oop"><span
class="header-section-number">2.1</span> OOP</h2>
<h3 data-number="2.1.1" id="final-finalizer-of-class"><span
class="header-section-number">2.1.1</span> <code>FINAL</code>: finalizer
of class</h3>
<p>One example is as follows. No memory will be lost. Note that the
defined type will be reclaimed after leaving a subroutine.</p>
<p><code>def.f90</code> is as follows,</p>
<pre><code>module def_mod
  !
  implicit none
  !
  public
  !
  type :: time_info_t
    !
    integer :: it = -1
    real :: time = -1.0
    real, dimension(:), allocatable :: arr
    !
    contains
    !
    procedure :: Init =&gt; InitTimeInfo
    ! final :: Decontructor =&gt; DestroyTimeInfo ! invalid syntax
    final :: DestroyTimeInfo
    !
  end type time_info_t
  !
  interface time_info_t
    module procedure TimeInfoConstructor
  end interface
  !
contains
  !
  function TimeInfoConstructor() result(time_info)
    !
    type(time_info_t) :: time_info
    !
    continue
    !
    time_info%it = 5
    time_info%time = 5.0
    allocate(time_info%arr(1:5),source=5.0)
    write(*,*) &quot;TimeInfoConstructor&quot;
    !
  end function TimeInfoConstructor
  !
  subroutine InitTimeInfo(this)
    !
    class(time_info_t) :: this
    !
    continue
    !
    this%it = 0
    this%time = 0.0
    allocate(this%arr(1:5),source=0.0)
    write(*,*) &quot;InitTimeInfo&quot;
    !
  end subroutine InitTimeInfo
  !
  subroutine DestroyTimeInfo(this)
    !
    type(time_info_t) :: this
    !
    continue
    !
    if (allocated(this%arr)) then
      deallocate(this%arr)
    end if
    write(*,*) &quot;DestroyTimeInfo&quot;
    !
  end subroutine DestroyTimeInfo
  !
end module def_mod</code></pre>
<p><code>main.f90</code> is as follows,</p>
<pre><code>program main
  !
  use def_mod, only : time_info_t
  !
  implicit none
  !
  type(time_info_t), allocatable :: tinfo
  !
  continue
  ! No mem lost after calling test().
  call test()
  ! Also no mem lost.
  allocate(tinfo, source=time_info_t())
  write(*,*) tinfo%it, tinfo%time
  deallocate(tinfo)
  !
contains
  !
  subroutine test()
    !
    type(time_info_t) :: tinfo
    !
    continue
    !
    call tinfo%Init()
    write(*,*) tinfo%it, tinfo%time
    !
  end subroutine test
  !
end program main</code></pre>
<h3 data-number="2.1.2"
id="function-as-user-defined-type-constructor"><span
class="header-section-number">2.1.2</span> Function as user-defined type
constructor</h3>
<pre><code>module Defs

  implicit none

  private
  public point, point2d, container

  type, abstract :: point ! Abstract parent type
    contains
      procedure(func), deferred :: radius ! Prototype for func supplied by abstract interface
  end type point

  abstract interface
    real function func( this )
      import point ! Need to import type information into interface
      class(point) this
    end function func
  end interface

  type, extends(point) :: point2d ! Child type
    real x, y
  contains
    procedure :: radius =&gt; r2d
  end type point2d

  type :: container
    class(point), allocatable :: ptr
  end type container

  interface point2d
    module procedure :: myinit
  end interface

contains
  !-----------------------------------
  real function r2d( this )
    class(point2d) this
    r2d = sqrt( this%x ** 2 + this%y ** 2 )
  end function r2d
  !-----------------------------------
  type(point2d) function myinit()
    myinit%x = 10
    myinit%y = 10
  end function myinit

end module Defs
!===========================================================
program main

  use Defs
  implicit none

  type(container), allocatable :: arr(:)
  type(point2d) :: b

  allocate(container::arr(2))

  arr(1)%ptr=point2d( 3, 4 )
  write(*, *) &quot;2-d radius is &quot;, arr(1)%ptr%radius()

  b = point2d()
  write(*, *) b%x, b%y, b%radius()

end program main</code></pre>
<h3 data-number="2.1.3" id="polymorphic-variable"><span
class="header-section-number">2.1.3</span> Polymorphic variable</h3>
<p>The polymorphic variable should be a feature of the Fortran 2003. But
Fortran 2018 should be better. Intel compiler 17 does not support it. I
use Intel compiler 19 with update 1 to compile the following codes.</p>
<pre><code>module Defs

  implicit none

  private
  public point, point2d, point3d, container

  type, abstract :: point ! Abstract parent type
    contains
      procedure(func), deferred :: radius ! Prototype for func supplied by abstract interface
  end type point

  abstract interface
    real function func( this )
      import point ! Need to import type information into interface
      class(point) this
    end function func
  end interface

  type, extends(point) :: point2d ! Child type
    real x, y
  contains
    procedure :: radius =&gt; r2d
  end type point2d

  type, extends(point2d) :: point3d ! Grandchild type!
    real z
  contains
    procedure :: radius =&gt; r3d
  end type point3d

  type :: container
    class(point), allocatable :: ptr
  end type container

contains
  !-----------------------------------
  real function r2d( this )
    class(point2d) this
    r2d = sqrt( this%x ** 2 + this%y ** 2 )
  end function r2d
  !-----------------------------------
  real function r3d( this )
    class(point3d) this
    r3d = sqrt( this%x ** 2 + this%y ** 2 + this%z ** 2 )
  end function r3d
  !-----------------------------------
end module Defs
!===========================================================
program main

  use Defs
  implicit none

  type(container), allocatable :: arr(:)

  allocate(container::arr(2))

  arr(1)%ptr=point2d( 3, 4 )
  write(*, *) &quot;2-d radius is &quot;, arr(1)%ptr%radius()
  arr(2)%ptr=point3d( 3, 4, 5 )
  write(*, *) &quot;3-d radius is &quot;, arr(2)%ptr%radius()

end program main</code></pre>
<h2 data-number="2.2" id="practices"><span
class="header-section-number">2.2</span> Practices</h2>
<h3 data-number="2.2.1" id="passing-null-pointer"><span
class="header-section-number">2.2.1</span> Passing null pointer</h3>
<p>Reference: <a
href="https://stackoverflow.com/questions/42374139/passing-a-null-pointer-actual-argument-to-a-member-procedure-of-a-derived-type">Passing
a null pointer actual argument to a member procedure of a derived
type</a></p>
<h3 data-number="2.2.2" id="multidimensional-array"><span
class="header-section-number">2.2.2</span> Multidimensional Array</h3>
<p>The performance of single dimensional array verus the
multidimensional array is shown as follows. The Fortran program is
compiled using the Intel compiler <code>ifort 17.0.5</code> with the
optimization flag <code>-O3 -xHost</code>. 10 times running shows that
<code>arr3(1:10240)%v(1:4,1:50,1:2)</code> is faster than
<code>arr3(1:10240)%v(1:1,1:400,1:1)</code>. However,
<code>arr3(1:10240)%v(1:1,1:512,1:1)</code> is faster than
<code>arr3(1:10240)%v(1:4,1:64,1:2)</code>. I attribute this behavior to
the vectorization. The multidimensional array performs similarly to the
one dimensional array.</p>
<pre><code>$ ~/software_profile/linux/time_sampling.sh /home/jcshi/learn/test_opt_1-512-1 10
No.1 run, the user time is 3.56s.
No.2 run, the user time is 3.48s.
No.3 run, the user time is 3.37s.
No.4 run, the user time is 3.35s.
No.5 run, the user time is 3.37s.
No.6 run, the user time is 3.47s.
No.7 run, the user time is 3.42s.
No.8 run, the user time is 4.48s.
No.9 run, the user time is 3.40s.
No.10 run, the user time is 3.41s.
Time sampling 10 times, with the averaged user time 3.5310s.

$ ~/software_profile/linux/time_sampling.sh /home/jcshi/learn/test_opt_4-64-2 10
No.1 run, the user time is 3.73s.
No.2 run, the user time is 3.69s.
No.3 run, the user time is 3.91s.
No.4 run, the user time is 3.85s.
No.5 run, the user time is 3.99s.
No.6 run, the user time is 3.72s.
No.7 run, the user time is 4.25s.
No.8 run, the user time is 4.15s.
No.9 run, the user time is 4.73s.
No.10 run, the user time is 3.58s.
Time sampling 10 times, with the averaged user time 3.9600s.</code></pre>
<p>The source codes are as follows,</p>
<pre><code>program test
  !
  type :: dof_t
    real(8), dimension(:,:,:), allocatable :: v
  end type dof_t
  !
  integer :: n,i, n1,n2,n3, k
  type(dof_t), dimension(:), allocatable :: arr3
  real :: tb,te
  !
continue
  !
  n = 10240
  allocate(arr3(1:n))
  !
  call cpu_time(tb)
  !
  ! n1 = 1
  ! n2 = 400
  ! n3 = 1
  n1 = 4
  n2 = 50
  n3 = 2
  do i = 1,n
    allocate(arr3(i)%v(1:n1,1:n2,1:n3))
  end do
  !
  do k = 1,1000
    !
    do i = 1,n
      arr3(i)%v(1:n1,1:n2,1:n3) = 100
      arr3(i)%v(1:n1,1:n2,1:n3) = arr3(i)%v(1:n1,1:n2,1:n3)**2
    end do
    !
  end do
  !
  call cpu_time(te)
  ! write(*,*) te-tb
  !
  do i = 1,n
    deallocate(arr3(i)%v)
  end do
  deallocate(arr3)
  !
end program</code></pre>
<h3 data-number="2.2.3" id="array-of-pointer"><span
class="header-section-number">2.2.3</span> Array of Pointer</h3>
<p><code>real, dimension(:), pointer :: ptr</code> does not define an
array of pointers, but a pointer to an array.</p>
<p>One way of defining the array of pointer is to define a type of
pointer and create an array of that type.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode fortran"><code class="sourceCode fortranfixed"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="dt">type</span> domainptr</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">type(domain)</span>, <span class="dt">pointer</span> <span class="dt">::</span> p</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="dt">end type</span> mytype</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="dt">type(domainptr)</span>, <span class="dt">dimension(3)</span> <span class="dt">::</span> dom</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>dom(<span class="dv">1</span>)%p <span class="kw">=</span><span class="op">&gt;</span> d01</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>dom(<span class="dv">2</span>)%p <span class="kw">=</span><span class="op">&gt;</span> d02</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>dom(<span class="dv">3</span>)%p <span class="kw">=</span><span class="op">&gt;</span> d03</span></code></pre></div>
<p>However, the pointer prevents the vectorization optimization. Check
the following example code.</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode fortran"><code class="sourceCode fortranfixed"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">program</span> test</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">integer</span>, <span class="dt">parameter</span> <span class="dt">::</span> wp <span class="kw">=</span> <span class="dv">8</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">type</span> <span class="dt">::</span> q_ptr</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">real(wp)</span>, <span class="dt">dimension(:,:)</span>, <span class="dt">pointer</span>, contiguous <span class="dt">::</span> p</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">end type</span> q_ptr</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">type(q_ptr)</span>, <span class="dt">dimension(1:2,1:2)</span> <span class="dt">::</span> q_ptr_mat</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real(wp)</span>, <span class="dt">dimension(:,:)</span>, <span class="dt">allocatable</span>, <span class="dt">target</span> <span class="dt">::</span> a,b,c</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real(wp)</span> <span class="dt">::</span> time_beg, time_end, s</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">integer</span> <span class="dt">::</span> nq, npts, i</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="co">continue</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">call</span> cpu_time(time_beg)</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>  nq <span class="kw">=</span> <span class="dv">4</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>  npts <span class="kw">=</span> <span class="dv">256</span><span class="kw">*</span><span class="dv">1024</span><span class="kw">*</span><span class="dv">128</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">allocate</span>(a(<span class="dv">1</span>:nq,<span class="dv">1</span>:npts))</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">allocate</span>(b(<span class="dv">1</span>:nq,<span class="dv">1</span>:npts))</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">allocate</span>(c(<span class="dv">1</span>:nq,<span class="dv">1</span>:npts))</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">call</span> <span class="fu">random_number</span>(a)</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">call</span> <span class="fu">random_number</span>(b)</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">call</span> <span class="fu">random_number</span>(c)</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">call</span> <span class="fu">random_number</span>(s)</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>  q_ptr_mat(<span class="dv">1</span>,<span class="dv">1</span>)%p <span class="kw">=</span><span class="op">&gt;</span> a</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>  q_ptr_mat(<span class="dv">2</span>,<span class="dv">1</span>)%p <span class="kw">=</span><span class="op">&gt;</span> b</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>  q_ptr_mat(<span class="dv">1</span>,<span class="dv">2</span>)%p <span class="kw">=</span><span class="op">&gt;</span> c</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>  <span class="co">! the pointer way</span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>  <span class="co">!DIR$ IVDEP</span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">do</span> i <span class="kw">=</span> <span class="dv">1</span>, <span class="dv">50</span></span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>    q_ptr_mat(<span class="dv">1</span>,<span class="dv">2</span>)%p(:,:) <span class="kw">=</span> q_ptr_mat(<span class="dv">2</span>,<span class="dv">1</span>)%p(:,:) <span class="kw">*</span> s <span class="kw">-</span> q_ptr_mat(<span class="dv">1</span>,<span class="dv">1</span>)%p<span class="co">(:,:)</span></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end do</span></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>  <span class="co">! the direct way</span></span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>  <span class="co">! !DIR$ IVDEP</span></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>  <span class="co">! do i = 1, 50</span></span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>  <span class="co">!   c = b * s - a</span></span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a>  <span class="co">! end do</span></span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a>  <span class="kw">call</span> cpu_time(time_end)</span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>  <span class="fu">write(*</span>,<span class="st">&quot;(&#39;Elapsed time: &#39;,f6.3)&quot;</span><span class="fu">)</span> time_end <span class="kw">-</span> time_beg</span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a><span class="kw">end program</span></span></code></pre></div>
<p>Use the Intel Fortran compiler to compile the optimized version
<code>ifort -O3 -xHost -qopt-report=5 -o test_opt test.f90</code>. The
optimization report is saved to <code>test.optrpt</code>. The pointer
way produces a different report compared to that by the direct way. The
key is if the compiler is able to vectorize
<code>q_ptr_mat(1,2)%p(:,:) = q_ptr_mat(2,1)%p(:,:) * s - q_ptr_mat(1,1)%p(:,:)</code>
or <code>c = b * s - a</code>. The report file of the pointer way shows
as follows,</p>
<pre><code>LOOP BEGIN at test.f90(25,3)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between Q_PTR(1,2,:,:) (26:5) and Q_PTR(1,2,:,:) (26:5)
   remark #15346: vector dependence: assumed OUTPUT dependence between Q_PTR(1,2,:,:) (26:5) and Q_PTR(1,2,:,:) (26:5)

   LOOP BEGIN at test.f90(26,5)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed FLOW dependence between Q_PTR(1,2,:,:) (26:5) and Q_PTR(2,1,:,:) (26:5)
      remark #15346: vector dependence: assumed ANTI dependence between Q_PTR(2,1,:,:) (26:5) and Q_PTR(1,2,:,:) (26:5)

      LOOP BEGIN at test.f90(26,5)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed FLOW dependence between Q_PTR(1,2,:,:) (26:5) and Q_PTR(2,1,:,:) (26:5)
         remark #15346: vector dependence: assumed ANTI dependence between Q_PTR(2,1,:,:) (26:5) and Q_PTR(1,2,:,:) (26:5)
      LOOP END
   LOOP END
LOOP END</code></pre>
<p>It shows that the compiler assumes that <code>q_ptr</code> has
dependence among its elements even though the compiler directive
<code>!DIR$ IVDEP</code> is added for that loop to tell the compiler
that this loop has no dependence. However, the direct way does not show
such dependence as follows,</p>
<pre><code>LOOP BEGIN at test.f90(29,3)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 3 ) --&gt; ( 2 1 3 ) 
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at test.f90(30,5)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at test.f90(30,5)
      &lt;Peeled loop for vectorization&gt;
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at test.f90(30,5)
         remark #15388: vectorization support: reference C(:,:) has aligned access
         remark #15389: vectorization support: reference B(:,:) has unaligned access
         remark #15389: vectorization support: reference A(:,:) has unaligned access   [ test.f90(30,11) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.472
         remark #15300: LOOP WAS VECTORIZED
         remark #15321: Compiler has chosen to target XMM/YMM vector. Try using -qopt-zmm-usage=high to override
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 8 
         remark #15477: vector cost: 2.250 
         remark #15478: estimated potential speedup: 3.150 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at test.f90(30,5)
      &lt;Remainder loop for vectorization&gt;
         remark #15389: vectorization support: reference C(:,:) has unaligned access
         remark #15389: vectorization support: reference B(:,:) has unaligned access
         remark #15389: vectorization support: reference A(:,:) has unaligned access   [ test.f90(30,11) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 1.818
         remark #15301: REMAINDER LOOP WAS VECTORIZED
      LOOP END

      LOOP BEGIN at test.f90(30,5)
      &lt;Remainder loop for vectorization&gt;
      LOOP END
   LOOP END
LOOP END</code></pre>
<ul>
<li>For the pointer alising, refer to <a
href="https://cvw.cac.cornell.edu/vector/coding_aliasing">Vectorization:
Pointer Aliasing</a>.</li>
<li>For the Intel compiler directive, refer to
<ul>
<li><a
href="https://software.intel.com/en-us/articles/explicit-vector-programming-in-fortran">Explicit
Vector Programming in Fortran</a></li>
<li><a
href="https://software.intel.com/en-us/articles/fdiag15346">Diagnostic
15346: vector dependence: assumed xxx dependence between line x and line
y</a></li>
<li><a
href="https://software.intel.com/en-us/fortran-compiler-developer-guide-and-reference-vector-and-novector">General
Compiler Directive: VECTOR and NOVECTOR</a></li>
</ul></li>
</ul>
<h3 data-number="2.2.4"
id="common-causes-of-segmentation-faults-segfaults"><span
class="header-section-number">2.2.4</span> Common Causes of Segmentation
Faults (Segfaults)</h3>
<p>Check <a
href="https://www.nas.nasa.gov/hecc/support/kb/common-causes-of-segmentation-faults-(segfaults)_524.html">Common
Causes of Segmentation Faults (Segfaults)</a>. Or check this <a
href="CommonCausesofSegmentationFaults(Segfaults).pdf">PDF</a>.</p>
<blockquote>
<p>However, the location of the segmentation fault might not be the root
problem—a segfault is often a symptom, rather than the cause of a
problem.</p>
</blockquote>
</div>
<div class="customHr">.</div>
<footer>
  Created on 2021-01-19 with pandoc
</footer>
</body>
</html>
